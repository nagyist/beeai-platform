# Deploy Kubernetes via MicroShift (which installs a bundled CRI-O).
# $ limactl start ./microshift.yaml
# $ limactl shell microshift kubectl
#
# It can be accessed from the host by exporting the kubeconfig file;
# the ports are already forwarded automatically by lima:
#
# $ export KUBECONFIG=$(limactl list microshift --format 'unix://{{.Dir}}/copied-from-guest/kubeconfig.yaml')
# $ kubectl get no
# NAME             STATUS   ROLES                         AGE   VERSION
# lima-microshift  Ready    control-plane,master,worker   69s   v1.30.0

# NOTE: MicroShift is designed for single-node deployments and does not natively support
# multi-node clustering like k3s. For multi-node Kubernetes, consider using k3s or full OpenShift.

minimumLimaVersion: 2.0.0

base: template:_images/ubuntu-lts

# Mounts are disabled in this template, but can be enabled optionally.
mounts: []

# CRI-O is managed by MicroShift, not by Lima, so the values are set to false here.
containerd:
  system: false
  user: false

provision:
- mode: system
  script: |
    #!/bin/bash
    set -eux -o pipefail

    # Check if MicroShift is already installed
    if ! command -v microshift &> /dev/null; then
        echo "Installing MicroShift from microshift.io repository..."

        # Add MicroShift repository
        curl -fsSL https://microshift.io/install.sh | bash

        # Update package lists
        apt-get update

        # Install MicroShift
        DEBIAN_FRONTEND=noninteractive apt-get install -y microshift

        # Configure MicroShift to use port 16443 (instead of default 6443)
        mkdir -p /etc/microshift
        cat > /etc/microshift/config.yaml <<EOF
    apiServer:
      port: 16443
    EOF

    # Configure CRI-O registry settings for insecure registries
    mkdir -p /etc/containers
    cat > /etc/containers/registries.conf <<EOF
    # Default registries configuration
    unqualified-search-registries = ["docker.io"]

    # Configuration for local insecure registry (to be used by Agent Stack)
    [[registry]]
    location = "agentstack-registry-svc.default:5001"
    insecure = true

    [[registry.mirror]]
    location = "localhost:30501"
    insecure = true
    EOF

        echo "Enabling and starting MicroShift service..."
        systemctl enable microshift
        systemctl start microshift
    else
        echo "MicroShift is already installed, ensuring it is started..."
        systemctl is-active microshift || systemctl start microshift
    fi

- mode: system
  script: |
    #!/bin/bash
    set -eux -o pipefail

    # Install kubectl if not present
    if ! command -v kubectl &> /dev/null; then
        echo "Installing kubectl..."

        # Detect architecture
        ARCH=$(uname -m)
        case "$ARCH" in
            x86_64)
                KUBECTL_ARCH="amd64"
                ;;
            aarch64|arm64)
                KUBECTL_ARCH="arm64"
                ;;
            *)
                echo "Unsupported architecture: $ARCH"
                exit 1
                ;;
        esac

        # Download and install kubectl
        KUBECTL_VERSION=$(curl -L -s https://dl.k8s.io/release/stable.txt)
        curl -LO "https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/${KUBECTL_ARCH}/kubectl"
        install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
        rm kubectl

        echo "kubectl installed successfully: $(kubectl version --client --short 2>/dev/null || kubectl version --client)"
    fi

- mode: system
  script: |
    #!/bin/bash
    set -eux -o pipefail

    # Wait for MicroShift to be fully ready and generate kubeconfig
    echo "Waiting for MicroShift to initialize..."
    timeout 300s bash -c 'until test -f /var/lib/microshift/resources/kubeadmin/kubeconfig; do sleep 3; done' || {
        echo "MicroShift did not initialize in time. Check logs with: journalctl -u microshift"
        exit 1
    }

    # Adjust kubeconfig permissions for easier access
    chmod 644 /var/lib/microshift/resources/kubeadmin/kubeconfig

    echo "MicroShift is ready!"

probes:
- script: |
    #!/bin/bash
    set -eux -o pipefail

    # Verify that MicroShift kubeconfig exists
    if ! test -f /var/lib/microshift/resources/kubeadmin/kubeconfig; then
        echo >&2 "MicroShift kubeconfig has not been created yet"
        exit 1
    fi

    # Verify that the API server is responding
    if ! timeout 10s kubectl --kubeconfig=/var/lib/microshift/resources/kubeadmin/kubeconfig get --raw /healthz &>/dev/null; then
        echo >&2 "MicroShift API server is not responding yet"
        exit 1
    fi

    echo "MicroShift is healthy and ready"
  hint: |
    The MicroShift kubeconfig file has not yet been created, or the API server is not ready.
    Run "limactl shell microshift sudo journalctl -u microshift" to check the service logs.
    Run "limactl shell microshift sudo systemctl status microshift" to check the service status.
    If the service hasn't started, check the cloud-init logs at "/var/log/cloud-init-output.log".

copyToHost:
- guest: "/var/lib/microshift/resources/kubeadmin/kubeconfig"
  host: "{{.Dir}}/copied-from-guest/kubeconfig.yaml"
  deleteOnStop: true

message: |
  To run `kubectl` on the host (assumes kubectl is installed), run the following commands:
  ------
  export KUBECONFIG="{{.Dir}}/copied-from-guest/kubeconfig.yaml"
  kubectl ...
  ------

  MicroShift API server is running on port 16443 (not the default 6443).

  To access the VM:
  ------
  limactl shell microshift
  ------

  To check MicroShift status:
  ------
  limactl shell microshift sudo systemctl status microshift
  limactl shell microshift sudo journalctl -u microshift -f
  ------

  NOTE: MicroShift is designed for single-node edge deployments.
  For multi-node clusters, consider using the k3s template instead.
